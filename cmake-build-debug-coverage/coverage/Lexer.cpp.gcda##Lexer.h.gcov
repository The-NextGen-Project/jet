        -:    0:Source:C:/Users/Owner/3DOBJE~1/jet/import/nextgen/jet/Lex/Lexer.h
        -:    0:Graph:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Lex\Lexer.cpp.gcno
        -:    0:Data:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Lex\Lexer.cpp.gcda
        -:    0:Runs:1
        -:    1:# ifndef NEXTGEN_LEXER_H
        -:    2:# define NEXTGEN_LEXER_H
        -:    3:
        -:    4:# include "Token.h"
        -:    5:namespace nextgen { namespace jet { using namespace nextgen::core;
        -:    6:
        -:    7:  enum LexErrorType {
        -:    8:    MalformedUTF8,
        -:    9:    InvalidChar,
        -:   10:    UnexpectedEOF,
        -:   11:    OutOfRange,
        -:   12:    Unreachable,
        -:   13:    IntegerOverflow,
        -:   14:    FloatingPointOverflow,
        -:   15:
        -:   16:    DigitOutOfRange,
        -:   17:    DoubleUnderscore,
        -:   18:
        -:   19:    MissingClosingForChar,
        -:   20:    MissingClosingForString,
        -:   21:
        -:   22:    InvalidDot,
        -:   23:    InvalidNumberValue
        -:   24:
        -:   25:  };
        -:   26:
        -:   27:  enum LexMode {
        -:   28:    TokenMode,
        -:   29:    PrintingMode
        -:   30:  };
        -:   31:
        -:   32:
        -:   33:  struct LexError {
        -:   34:    LexErrorType Error;
        -:   35:    TokenTraits::SourceLocation Location;
        -:   36:    Token FailedToken;
        -:   37:  };
        -:   38:
        -:   39:
        -:   40:  class Lexer {
        -:   41:    using Allocator = mem::ArenaSegment;
        -:   42:    using File = char;
        -:   43:
        -:   44:    Allocator   *Memory;
        -:   45:    const File  *Buffer;
        -:   46:    const size_t BufferSize;
        -:   47:
        -:   48:    size_t CurrentLine    = 1;
        -:   49:    size_t CurrentColumn  = 1;
        -:   50:    size_t BufferPosition = 0;
        -:   51:
        -:   52:    LexMode Mode;
        -:   53:
        -:   54:  public:
        -:   55:
        -:   56:    /// Initialization of values through Lexer::New
        -:   57:    static auto New(Allocator *Mem, const File *Buffer,
        -:   58:                    const size_t BufferLength,
        -:   59:                    LexMode Mode = LexMode::TokenMode) -> Lexer {
        -:   60:      Lexer Instance = Lexer(Mem, Buffer, BufferLength);
        -:   61:      Instance.Mode = Mode;
        -:   62:      return Instance;
        -:   63:    }
        -:   64:
        -:   65:    /// Get the next valid Token in the File stream
        -:   66:    auto NextToken() -> Result<Token, LexError>;
        -:   67:
        -:   68:    /// Print the values of token with Syntax Highlighting
        -:   69:    void PrintNextToken();
        -:   70:
        -:   71:    /// Lex all tokens. If an error is encountered, report it
        -:   72:    /// and count it as fatal. Compiler cannot proceed without
        -:   73:    /// lexing phase being valid.
        -:   74:    NG_INLINE auto Lex() -> Vec<Token> {
        -:   75:      Vec<Token> Tokens = Vec<Token>::New();
        -:   76:      do {
        -:   77:        auto Instance = NextToken();
        -:   78:        if (Instance.IsErr()) {
        -:   79:          // TODO: Handle Error
        -:   80:        }
        -:   81:        Tokens.Add(Instance.Unwrap());
        -:   82:      } while (Buffer);
        -:   83:      return Tokens;
        -:   84:    }
        -:   85:
        -:   86:    /// Print the tokens using syntax highlighting with the given
        -:   87:    /// buffer. Used for Re-lexing in error reporting.
        -:   88:    NG_INLINE void LexPrint() noexcept {
        -:   89:      do {
        -:   90:        PrintNextToken();
        -:   91:      } while (BufferPosition < BufferSize);
        -:   92:    }
        -:   93:
        -:   94:
        -:   95:    /// Peek `NChars` characters in the file buffer.
        1:   96:    NG_INLINE auto Peek(size_t NChars) -> char {
        1:   97:      return *(Buffer + NChars);
        1:   97-block  0
        -:   98:    }
        -:   99:
        -:  100:    /// Get the latest character in the file buffer
        -:  101:    NG_AINLINE auto Curr() -> char const {
      77*:  102:      return *Buffer;
        4:  102-block  0
        1:  102-block  1
       26:  102-block  2
        1:  102-block  3
        9:  102-block  4
    %%%%%:  102-block  5
        2:  102-block  6
        4:  102-block  7
        1:  102-block  8
       17:  102-block  9
    %%%%%:  102-block 10
        7:  102-block 11
    %%%%%:  102-block 12
    %%%%%:  102-block 13
    %%%%%:  102-block 14
        -:  103:    }
        -:  104:
        -:  105:    /// Move the lexer forward by `NChars` and fill in `Error` for
        -:  106:    /// unexpected EOF or Out of Range Error that may be encountered.
       71:  107:    NG_INLINE auto Next(size_t NChars) -> char {
        -:  108:
       71:  109:      if (BufferPosition >= BufferSize) {
       71:  109-block  0
        -:  110:
        -:  111:        // TODO: Get Diagnostics Working in Panic Situation
        1:  112:        LexError Error = LexError {
        -:  113:          LexErrorType::OutOfRange,
        1:  114:          { CurrentLine, CurrentColumn }
        1:  115:        };
        1:  115-block  0
        -:  116:
        1:  117:        return '\0';
        -:  118:      }
        -:  119:
       70:  120:      CurrentColumn += NChars;
       70:  121:      BufferPosition += NChars;
       70:  122:      Buffer += NChars;
       70:  123:      return *Buffer;
       70:  123-block  0
        -:  124:    }
        -:  125:
        -:  126:  private:
        -:  127:
        -:  128:    /// Initializer Shadow Constructor
        -:  129:    Lexer(Allocator *Mem, const File *Buffer, const size_t BufSize)
        -:  130:    : Memory(Mem), Buffer(Buffer), BufferSize(BufSize) {}
        -:  131:
        -:  132:    /// Matches a new line encountered in the buffer and handles
        -:  133:    /// them appropriately depending on \n or \r.
    #####:  134:    NG_INLINE void SkipNewLine() {
    #####:  135:      CurrentLine++;
    #####:  136:      char Current = *Buffer;
    #####:  137:      char NextCh  = Next(1);
    %%%%%:  137-block  0
    #####:  138:      match(Current, NextCh) {
    #####:  139:        group('\n', '\r'):
        -:  140:        group ('\r', '\n'): {
    #####:  141:          if (Mode == LexMode::PrintingMode) { // Handle Print Case
    %%%%%:  141-block  0
    #####:  142:            Console::Log(NextCh);
    %%%%%:  142-block  0
        -:  143:          }
    #####:  144:          ++CurrentLine, Next(1);
    %%%%%:  144-block  0
        -:  145:        }
    #####:  146:        default:
    #####:  147:          break;
    %%%%%:  147-block  0
        -:  148:      }
    #####:  149:    }
        -:  150:
        -:  151:  };
        -:  152:
        -:  153:
        -:  154:}} // namespace nextgen::jet
        -:  155:
        -:  156:
        -:  157:
        -:  158:# endif //NEXTGEN_LEXER_H
