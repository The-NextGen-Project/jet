        -:    0:Source:C:/Users/Owner/3D Objects/jet/lib/Support/IO.cpp
        -:    0:Graph:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Support\IO.cpp.gcno
        -:    0:Data:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Support\IO.cpp.gcda
        -:    0:Runs:1
        -:    1:# include <nextgen/Support/IO.h>
        -:    2:
        -:    3:
        -:    4:using namespace nextgen::io;
        -:    5:
        -:    6:// Read a file using the standard library and outputs a FileBuf
        -:    7:// with the contents. TODO: Can this be more portable??
    #####:    8:FileBuf GetFileBuffer(const char *FILE, FileID ID) {
    #####:    9:  auto read = std::ifstream(FILE, std::ios::binary);
    %%%%%:    9-block  0
    $$$$$:    9-block  1
    #####:   10:  auto buf  = read.rdbuf();
    %%%%%:   10-block  0
    #####:   11:  auto size = read.tellg();
    %%%%%:   11-block  0
        -:   12:
    #####:   13:  auto block = static_cast<char*>(nextgen::mem::os::malloc(size));
    %%%%%:   13-block  0
    #####:   14:  buf->sgetn(block, size);
    %%%%%:   14-block  0
        -:   15:
    #####:   16:  return { block, ID };
    %%%%%:   16-block  0
    %%%%%:   16-block  1
        -:   17:}
        -:   18:
        -:   19:// Given a list of files, output the type of file given. For example,
        -:   20:// given a list of source code for Jet, and set it to output a binary
        -:   21:// ELF, it will output an ELF binary for the given source input.
        -:   22://
        -:   23:// Example:
        -:   24:// FileBuf files[] = ...
        -:   25:// FileBuf::Output(files, FiledID::LLVM_IR);
    #####:   26:void FileBuf::Output(FileBuf *files, FileID output) {
        -:   27:
    #####:   28:}
