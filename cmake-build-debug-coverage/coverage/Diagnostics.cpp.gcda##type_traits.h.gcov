        -:    0:Source:C:/msys64/mingw64/include/c++/10.2.0/ext/type_traits.h
        -:    0:Graph:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Diagnostics.cpp.gcno
        -:    0:Data:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Diagnostics.cpp.gcda
        -:    0:Runs:1
        -:    1:// -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2005-2020 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the terms
        -:    7:// of the GNU General Public License as published by the Free Software
        -:    8:// Foundation; either version 3, or (at your option) any later
        -:    9:// version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful, but
        -:   12:// WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   14:// General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file ext/type_traits.h
        -:   26: *  This file is a GNU extension to the Standard C++ Library.
        -:   27: */
        -:   28:
        -:   29:#ifndef _EXT_TYPE_TRAITS
        -:   30:#define _EXT_TYPE_TRAITS 1
        -:   31:
        -:   32:#pragma GCC system_header
        -:   33:
        -:   34:#include <bits/c++config.h>
        -:   35:#include <bits/cpp_type_traits.h>
        -:   36:
        -:   37:extern "C++" {
        -:   38:
        -:   39:namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
        -:   40:{
        -:   41:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   42:
        -:   43:  // Define a nested type if some predicate holds.
        -:   44:  template<bool, typename>
        -:   45:    struct __enable_if 
        -:   46:    { };
        -:   47:
        -:   48:  template<typename _Tp>
        -:   49:    struct __enable_if<true, _Tp>
        -:   50:    { typedef _Tp __type; };
        -:   51:
        -:   52:
        -:   53:  // Conditional expression for types. If true, first, if false, second.
        -:   54:  template<bool _Cond, typename _Iftrue, typename _Iffalse>
        -:   55:    struct __conditional_type
        -:   56:    { typedef _Iftrue __type; };
        -:   57:
        -:   58:  template<typename _Iftrue, typename _Iffalse>
        -:   59:    struct __conditional_type<false, _Iftrue, _Iffalse>
        -:   60:    { typedef _Iffalse __type; };
        -:   61:
        -:   62:
        -:   63:  // Given an integral builtin type, return the corresponding unsigned type.
        -:   64:  template<typename _Tp>
        -:   65:    struct __add_unsigned
        -:   66:    { 
        -:   67:    private:
        -:   68:      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        -:   69:      
        -:   70:    public:
        -:   71:      typedef typename __if_type::__type __type; 
        -:   72:    };
        -:   73:
        -:   74:  template<>
        -:   75:    struct __add_unsigned<char>
        -:   76:    { typedef unsigned char __type; };
        -:   77:
        -:   78:  template<>
        -:   79:    struct __add_unsigned<signed char>
        -:   80:    { typedef unsigned char __type; };
        -:   81:
        -:   82:  template<>
        -:   83:    struct __add_unsigned<short>
        -:   84:    { typedef unsigned short __type; };
        -:   85:
        -:   86:  template<>
        -:   87:    struct __add_unsigned<int>
        -:   88:    { typedef unsigned int __type; };
        -:   89:
        -:   90:  template<>
        -:   91:    struct __add_unsigned<long>
        -:   92:    { typedef unsigned long __type; };
        -:   93:
        -:   94:  template<>
        -:   95:    struct __add_unsigned<long long>
        -:   96:    { typedef unsigned long long __type; };
        -:   97:
        -:   98:  // Declare but don't define.
        -:   99:  template<>
        -:  100:    struct __add_unsigned<bool>;
        -:  101:
        -:  102:  template<>
        -:  103:    struct __add_unsigned<wchar_t>;
        -:  104:
        -:  105:
        -:  106:  // Given an integral builtin type, return the corresponding signed type.
        -:  107:  template<typename _Tp>
        -:  108:    struct __remove_unsigned
        -:  109:    { 
        -:  110:    private:
        -:  111:      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        -:  112:      
        -:  113:    public:
        -:  114:      typedef typename __if_type::__type __type; 
        -:  115:    };
        -:  116:
        -:  117:  template<>
        -:  118:    struct __remove_unsigned<char>
        -:  119:    { typedef signed char __type; };
        -:  120:
        -:  121:  template<>
        -:  122:    struct __remove_unsigned<unsigned char>
        -:  123:    { typedef signed char __type; };
        -:  124:
        -:  125:  template<>
        -:  126:    struct __remove_unsigned<unsigned short>
        -:  127:    { typedef short __type; };
        -:  128:
        -:  129:  template<>
        -:  130:    struct __remove_unsigned<unsigned int>
        -:  131:    { typedef int __type; };
        -:  132:
        -:  133:  template<>
        -:  134:    struct __remove_unsigned<unsigned long>
        -:  135:    { typedef long __type; };
        -:  136:
        -:  137:  template<>
        -:  138:    struct __remove_unsigned<unsigned long long>
        -:  139:    { typedef long long __type; };
        -:  140:
        -:  141:  // Declare but don't define.
        -:  142:  template<>
        -:  143:    struct __remove_unsigned<bool>;
        -:  144:
        -:  145:  template<>
        -:  146:    struct __remove_unsigned<wchar_t>;
        -:  147:
        -:  148:
        -:  149:  // For use in string and vstring.
        -:  150:  template<typename _Type>
        -:  151:    inline bool
    #####:  152:    __is_null_pointer(_Type* __ptr)
    #####:  153:    { return __ptr == 0; }
    %%%%%:  153-block  0
        -:  154:
        -:  155:  template<typename _Type>
        -:  156:    inline bool
        -:  157:    __is_null_pointer(_Type)
        -:  158:    { return false; }
        -:  159:
        -:  160:#if __cplusplus >= 201103L
        -:  161:  inline bool
        -:  162:  __is_null_pointer(std::nullptr_t)
        -:  163:  { return true; }
        -:  164:#endif
        -:  165:
        -:  166:  // For complex and cmath
        -:  167:  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
        -:  168:    struct __promote
        -:  169:    { typedef double __type; };
        -:  170:
        -:  171:  // No nested __type member for non-integer non-floating point types,
        -:  172:  // allows this type to be used for SFINAE to constrain overloads in
        -:  173:  // <cmath> and <complex> to only the intended types.
        -:  174:  template<typename _Tp>
        -:  175:    struct __promote<_Tp, false>
        -:  176:    { };
        -:  177:
        -:  178:  template<>
        -:  179:    struct __promote<long double>
        -:  180:    { typedef long double __type; };
        -:  181:
        -:  182:  template<>
        -:  183:    struct __promote<double>
        -:  184:    { typedef double __type; };
        -:  185:
        -:  186:  template<>
        -:  187:    struct __promote<float>
        -:  188:    { typedef float __type; };
        -:  189:
        -:  190:  template<typename _Tp, typename _Up,
        -:  191:           typename _Tp2 = typename __promote<_Tp>::__type,
        -:  192:           typename _Up2 = typename __promote<_Up>::__type>
        -:  193:    struct __promote_2
        -:  194:    {
        -:  195:      typedef __typeof__(_Tp2() + _Up2()) __type;
        -:  196:    };
        -:  197:
        -:  198:  template<typename _Tp, typename _Up, typename _Vp,
        -:  199:           typename _Tp2 = typename __promote<_Tp>::__type,
        -:  200:           typename _Up2 = typename __promote<_Up>::__type,
        -:  201:           typename _Vp2 = typename __promote<_Vp>::__type>
        -:  202:    struct __promote_3
        -:  203:    {
        -:  204:      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
        -:  205:    };
        -:  206:
        -:  207:  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
        -:  208:           typename _Tp2 = typename __promote<_Tp>::__type,
        -:  209:           typename _Up2 = typename __promote<_Up>::__type,
        -:  210:           typename _Vp2 = typename __promote<_Vp>::__type,
        -:  211:           typename _Wp2 = typename __promote<_Wp>::__type>
        -:  212:    struct __promote_4
        -:  213:    {
        -:  214:      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
        -:  215:    };
        -:  216:
        -:  217:_GLIBCXX_END_NAMESPACE_VERSION
        -:  218:} // namespace
        -:  219:} // extern "C++"
        -:  220:
        -:  221:#endif 
