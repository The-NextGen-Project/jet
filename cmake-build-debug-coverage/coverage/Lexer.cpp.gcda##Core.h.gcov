        -:    0:Source:C:/Users/Owner/3DOBJE~1/jet/import/nextgen/Support/Core.h
        -:    0:Graph:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Lex\Lexer.cpp.gcno
        -:    0:Data:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\lib\Lex\Lexer.cpp.gcda
        -:    0:Runs:1
        -:    1:# ifndef NEXTGEN_CORE_H
        -:    2:# define NEXTGEN_CORE_H
        -:    3:
        -:    4:# include "None.h"
        -:    5:
        -:    6:namespace nextgen { namespace core {
        -:    7:
        -:    8:  namespace detail {
        -:    9:
        -:   10:    // PartialEq Equivalent in C++.
        -:   11:    template<typename T, typename K, typename = K>
        -:   12:    struct PartialEq : std::false_type {};
        -:   13:
        -:   14:    template<typename T, typename K>
        -:   15:    struct PartialEq<T, K,
        -:   16:      decltype(
        -:   17:      // In Rust, a PartialEq value must have the '==' operator and the '!='
        -:   18:      // operator overloaded.
        -:   19:      std::declval<T>() == std::declval<T>() &&
        -:   20:      std::declval<T>() != std::declval<T>()
        -:   21:      )>
        -:   22:      : std::true_type {
        -:   23:    };
        -:   24:
        -:   25:  }
        -:   26:  template<typename T, typename K = bool>
        -:   27:  struct PartialEq : detail::PartialEq<T, K> {};
        -:   28:
        -:   29:  /// Optional Type Value - Emulates Rust's style of an optional value in C++11.
        -:   30:  /// We must ensure that values are owned by the value when passed.
        -:   31:  template<typename T>
        -:   32:  class Option {
        -:   33:  public:
        -:   34:
        -:   35:    explicit Option(T &value) :
        -:   36:    Some(std::move(value)), is(true) {}
        -:   37:
        -:   38:    /*implicit*/ Option(NoneValue) :
        -:   39:    is(false) {}
        -:   40:
        -:   41:    NG_AINLINE bool isSome() {
        -:   42:      return is;
        -:   43:    }
        -:   44:
        -:   45:    NG_AINLINE bool isNone() {
        -:   46:      return !is;
        -:   47:    }
        -:   48:
        -:   49:    template<typename U, typename = std::enable_if<PartialEq<T>::value>>
        -:   50:    bool Contains(U x) {
        -:   51:      if (is) return x == Some;
        -:   52:      return false;
        -:   53:    }
        -:   54:
        -:   55:    T Unwrap() {
        -:   56:      ASSERT(is, "Unwrapped on None Value");
        -:   57:      return std::move(Some);
        -:   58:    }
        -:   59:
        -:   60:    template<typename Lambda, LAMBDA(Lambda, T, void)>
        -:   61:    T UnwrapOrElse(Lambda f) {
        -:   62:      if (is) return std::move(Some);
        -:   63:      return f();
        -:   64:    }
        -:   65:
        -:   66:  private:
        -:   67:    T Some;
        -:   68:    bool is;
        -:   69:  };
        -:   70:
        -:   71:  namespace detail {
        -:   72:    enum OkResult {
        -:   73:      Ok
        -:   74:    };
        -:   75:    enum ErrResult {
        -:   76:      Err
        -:   77:    };
        -:   78:  }
        -:   79:
        -:   80:  template<typename T, typename E>
        -:   81:  class Result {
        -:   82:  public:
        -:   83:
        3:   84:    /*implicit*/ Result(detail::OkResult, T &ok)
        3:   85:      : Ok(ok), is(true) {}
        3:   85-block  0
        -:   86:
        -:   87:
        1:   88:    /*implicit*/ Result(detail::ErrResult, E err)
        1:   89:      : Err(err), is(false) {}
        1:   89-block  0
        -:   90:
        -:   91:    NG_AINLINE bool IsOk() {
        -:   92:      return is;
        -:   93:    }
        -:   94:
        -:   95:    NG_AINLINE bool IsErr() {
        -:   96:      return !is;
        -:   97:    }
        -:   98:
        -:   99:    template<typename U, typename = std::enable_if<PartialEq<U>::value>>
        -:  100:    bool Contains(U x) {
        -:  101:      if (is) return x == Ok;
        -:  102:      return false;
        -:  103:    }
        -:  104:
        -:  105:    auto Error() -> Option<E> {
        -:  106:      if (!is) return Option<E>(Err);
        -:  107:      return None;
        -:  108:    }
        -:  109:
        -:  110:    auto AsRef() -> Result<T &, E &>{
        -:  111:      if (is) return Result(&Ok);
        -:  112:      return Result(&Err);
        -:  113:    }
        -:  114:
        -:  115:    template<typename Lambda, LAMBDA(Lambda, T, Result<T, E>)>
        -:  116:    auto AndThen(Lambda op) -> Result<T, E>  {
        -:  117:      if (is) return op(Ok);
        -:  118:      return Result(Err);
        -:  119:    }
        -:  120:
        -:  121:    T Unwrap() {
        -:  122:      ASSERT(is, "Unwrapped Error Result!");
        -:  123:      return Ok;
        -:  124:    }
        -:  125:
        -:  126:  private:
        -:  127:    T Ok;
        -:  128:    E Err;
        -:  129:    bool is;
        -:  130:  };
        -:  131:
        -:  132:
        -:  133:  template<typename T, typename E>
        3:  134:  static auto Ok(T value) -> Result<T, E> {
        3:  135:    return Result<T, E>(detail::OkResult::Ok, value);
        3:  135-block  0
        -:  136:  }
        -:  137:
        -:  138:  template<typename T, typename E>
        1:  139:  static auto Err(E value) -> Result<T, E> {
        1:  140:    return Result<T, E>(detail::ErrResult::Err, value);
        1:  140-block  0
        -:  141:  }
        -:  142:
        -:  143:  template<typename T>
        -:  144:  static NG_AINLINE auto Some(T value) -> Option<T> {
        -:  145:    return Option<T>(value); // Make explicit
        -:  146:  }
        -:  147:
        -:  148:
        -:  149:}} // namespace nextgen::core
        -:  150:
        -:  151:
        -:  152:#endif //NEXTGEN_CORE_H
