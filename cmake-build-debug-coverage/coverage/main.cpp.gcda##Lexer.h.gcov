        -:    0:Source:C:/Users/Owner/3DOBJE~1/jet/import/nextgen/jet/Lex/Lexer.h
        -:    0:Graph:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\main.cpp.gcno
        -:    0:Data:C:\Users\Owner\3D Objects\jet\cmake-build-debug-coverage\CMakeFiles\jet.dir\main.cpp.gcda
        -:    0:Runs:1
        -:    1:# ifndef NEXTGEN_LEXER_H
        -:    2:# define NEXTGEN_LEXER_H
        -:    3:
        -:    4:# include "Token.h"
        -:    5:namespace nextgen { namespace jet { using namespace nextgen::core;
        -:    6:
        -:    7:  enum LexErrorType {
        -:    8:    MalformedUTF8,
        -:    9:    InvalidChar,
        -:   10:    UnexpectedEOF,
        -:   11:    OutOfRange,
        -:   12:    Unreachable,
        -:   13:    IntegerOverflow,
        -:   14:    FloatingPointOverflow,
        -:   15:
        -:   16:    DigitOutOfRange,
        -:   17:    DoubleUnderscore,
        -:   18:
        -:   19:    MissingClosingForChar,
        -:   20:    MissingClosingForString,
        -:   21:
        -:   22:    InvalidDot,
        -:   23:    InvalidNumberValue
        -:   24:
        -:   25:  };
        -:   26:
        -:   27:  enum LexMode {
        -:   28:    TokenMode,
        -:   29:    PrintingMode
        -:   30:  };
        -:   31:
        -:   32:
        -:   33:  struct LexError {
        -:   34:    LexErrorType Error;
        -:   35:    TokenTraits::SourceLocation Location;
        -:   36:    Token FailedToken;
        -:   37:  };
        -:   38:
        -:   39:
        -:   40:  class Lexer {
        -:   41:    using Allocator = mem::ArenaSegment;
        -:   42:    using File = char;
        -:   43:
        -:   44:    Allocator   *Memory;
        -:   45:    const File  *Buffer;
        -:   46:    const size_t BufferSize;
        -:   47:
        -:   48:    size_t CurrentLine    = 1;
        -:   49:    size_t CurrentColumn  = 1;
        -:   50:    size_t BufferPosition = 0;
        -:   51:
        -:   52:    LexMode Mode;
        -:   53:
        -:   54:  public:
        -:   55:
        -:   56:    /// Initialization of values through Lexer::New
        2:   57:    static auto New(Allocator *Mem, const File *Buffer,
        -:   58:                    const size_t BufferLength,
        -:   59:                    LexMode Mode = LexMode::TokenMode) -> Lexer {
        2:   60:      Lexer Instance = Lexer(Mem, Buffer, BufferLength);
        2:   60-block  0
        2:   61:      Instance.Mode = Mode;
        2:   62:      return Instance;
        -:   63:    }
        -:   64:
        -:   65:    /// Get the next valid Token in the File stream
        -:   66:    auto NextToken() -> Result<Token, LexError>;
        -:   67:
        -:   68:    /// Print the values of token with Syntax Highlighting
        -:   69:    void PrintNextToken();
        -:   70:
        -:   71:    /// Lex all tokens. If an error is encountered, report it
        -:   72:    /// and count it as fatal. Compiler cannot proceed without
        -:   73:    /// lexing phase being valid.
        -:   74:    NG_INLINE auto Lex() -> Vec<Token> {
        -:   75:      Vec<Token> Tokens = Vec<Token>::New();
        -:   76:      do {
        -:   77:        auto Instance = NextToken();
        -:   78:        if (Instance.IsErr()) {
        -:   79:          // TODO: Handle Error
        -:   80:        }
        -:   81:        Tokens.Add(Instance.Unwrap());
        -:   82:      } while (Buffer);
        -:   83:      return Tokens;
        -:   84:    }
        -:   85:
        -:   86:    /// Print the tokens using syntax highlighting with the given
        -:   87:    /// buffer. Used for Re-lexing in error reporting.
        -:   88:    NG_INLINE void LexPrint() noexcept {
        -:   89:      do {
        -:   90:        PrintNextToken();
        -:   91:      } while (BufferPosition < BufferSize);
        -:   92:    }
        -:   93:
        -:   94:
        -:   95:    /// Peek `NChars` characters in the file buffer.
        -:   96:    NG_INLINE auto Peek(size_t NChars) -> char {
        -:   97:      return *(Buffer + NChars);
        -:   98:    }
        -:   99:
        -:  100:    /// Get the latest character in the file buffer
        -:  101:    NG_AINLINE auto Curr() -> char const {
        -:  102:      return *Buffer;
        -:  103:    }
        -:  104:
        -:  105:    /// Move the lexer forward by `NChars` and fill in `Error` for
        -:  106:    /// unexpected EOF or Out of Range Error that may be encountered.
        -:  107:    NG_INLINE auto Next(size_t NChars) -> char {
        -:  108:
        -:  109:      if (BufferPosition >= BufferSize) {
        -:  110:
        -:  111:        // TODO: Get Diagnostics Working in Panic Situation
        -:  112:        LexError Error = LexError {
        -:  113:          LexErrorType::OutOfRange,
        -:  114:          { CurrentLine, CurrentColumn }
        -:  115:        };
        -:  116:
        -:  117:        return '\0';
        -:  118:      }
        -:  119:
        -:  120:      CurrentColumn += NChars;
        -:  121:      BufferPosition += NChars;
        -:  122:      Buffer += NChars;
        -:  123:      return *Buffer;
        -:  124:    }
        -:  125:
        -:  126:  private:
        -:  127:
        -:  128:    /// Initializer Shadow Constructor
        2:  129:    Lexer(Allocator *Mem, const File *Buffer, const size_t BufSize)
        2:  130:    : Memory(Mem), Buffer(Buffer), BufferSize(BufSize) {}
        -:  131:
        -:  132:    /// Matches a new line encountered in the buffer and handles
        -:  133:    /// them appropriately depending on \n or \r.
        -:  134:    NG_INLINE void SkipNewLine() {
        -:  135:      CurrentLine++;
        -:  136:      char Current = *Buffer;
        -:  137:      char NextCh  = Next(1);
        -:  138:      match(Current, NextCh) {
        -:  139:        group('\n', '\r'):
        -:  140:        group ('\r', '\n'): {
        -:  141:          if (Mode == LexMode::PrintingMode) { // Handle Print Case
        -:  142:            Console::Log(NextCh);
        -:  143:          }
        -:  144:          ++CurrentLine, Next(1);
        -:  145:        }
        -:  146:        default:
        -:  147:          break;
        -:  148:      }
        -:  149:    }
        -:  150:
        -:  151:  };
        -:  152:
        -:  153:
        -:  154:}} // namespace nextgen::jet
        -:  155:
        -:  156:
        -:  157:
        -:  158:# endif //NEXTGEN_LEXER_H
